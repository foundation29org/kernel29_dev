# Summary of `judge_semantic_async.py`

This script evaluates the semantic relationship between LLM-generated differential diagnoses and the corresponding golden standard diagnosis for clinical cases stored in a database. It uses another LLM (the "semantic judge") to assess each ranked diagnosis produced by a target LLM against the known correct diagnosis.

## Purpose

The primary goal is to asynchronously process numerous LLM-generated differential diagnoses, judge the semantic relationship (e.g., Exact Synonym, Broad Synonym, Related Disease Group, Not Related) of each ranked diagnosis relative to the golden standard diagnosis using a designated semantic judge model, and store these relationship judgments back into the database. This allows for analysis of the clinical relevance and accuracy of the LLM's diagnostic suggestions.

## General Technical Overview

Here's a high-level overview of what this script does:
1.  Connects to a database containing clinical cases, their correct ("golden standard") diagnoses, and differential diagnoses previously generated by different AI models.
2.  Selects differential diagnoses generated by a specific AI model (e.g., 'llama2_7b') for a particular dataset (e.g., 'ramedis').
3.  For each case, it formats a text prompt containing both the golden standard diagnosis and the ranked list of diagnoses generated by the target AI model.
4.  Sends these prompts asynchronously (many at once) to another AI model (the "semantic judge", e.g., 'llama3-70b').
5.  Receives the semantic relationship judgments (e.g., "Exact synonym", "Related Disease Group", "Not related") back from the semantic judge AI, indicating how closely each AI-generated diagnosis matches the golden standard.
6.  Parses these text-based judgments into a structured format.
7.  Stores the structured semantic relationship results back into the database.

The script can run using command-line arguments for automation (Endpoint Mode) or using fixed settings coded directly into the script for debugging (Debug Mode).

## Detailed Technical Overview

### Execution Modes

The script supports two execution modes, determined by the presence of the `--semantic_judge` command-line argument:

1.  **Endpoint Mode:**
    *   Triggered when `--semantic_judge` (and potentially other arguments like `--differential_diagnosis_model`, `--batch_size`, etc.) is provided.
    *   Uses command-line arguments to configure settings (models, batching parameters, etc.).
    *   Follows a structured, refactored execution path using the `main` function and helper functions (`set_settings`, `retrieve_and_make_prompts`, `process_results`).
    *   This is the intended mode for automated or production-like runs.

2.  **Debug Mode:**
    *   Triggered when `--semantic_judge` is *not* provided.
    *   Uses hardcoded settings defined directly within the `if __name__ == "__main__":` block.
    *   Executes the core logic sequentially within the `else` block, *without* calling the refactored `main` or helper functions. The code in this block remains untouched from its original state for debugging and comparison purposes.

### Core Logic Flow (Endpoint Mode)

When run in Endpoint mode, the script follows these steps orchestrated by the `main` function:

1.  **Argument Parsing:** Reads command-line arguments to set parameters.
2.  **Settings Initialization (`set_settings`):**
    *   Establishes a database session (`get_session`).
    *   Initializes the asynchronous API handler (`AsyncModelHandler`).
    *   Loads the specified prompt template for the semantic judge (e.g., `Semantic_prompt()`).
3.  **Data Retrieval and Transformation (`retrieve_and_make_prompts`):**
    *   Fetches relevant ranked diagnosis records (`DifferentialDiagnosis2Rank` objects) from the database based on the target `differential_diagnosis_model` and `test_name` (hospital).
    *   Fetches the golden standard diagnosis for each relevant case (`get_cases`, `get_case_to_golden_diagnosis_mapping`).
    *   **Groups** the flat rank records into a list of nested dictionaries, where each dictionary represents one full differential diagnosis set for a specific case/model (`create_nested_diagnosis_dict`).
    *   **Formats** each nested dictionary into a single plain text string containing *both* the golden diagnosis and the ranked LLM diagnoses, mapped to a unique composite key (`f"{case_id}_{model_id}_{diff_diag_id}"`) in a flat dictionary (`dif_diagnosis_dict2plain_text_dict_with_real_diagnosis`).
    *   **Wraps** each key-value pair from the flat dictionary into a simple object (`DiagnosisTextWrapper`) having `.id` (the composite key) and `.text` (golden + ranked diagnoses string) attributes (`convert_dict_to_objects`). This final list of wrapper objects is required by the batch processing library (`process_all_batches`).
    *   Also creates an intermediate dictionary (`ranked_differential_diagnosis_nested_dict`) mapping the composite keys back to the original rank details (`nested_dict2rank_dict`), used later for result parsing.
4.  **Asynchronous Batch Processing (`process_all_batches`):**
    *   Takes the list of `DiagnosisTextWrapper` objects.
    *   Uses the `AsyncModelHandler` and the loaded prompt template (`semantic_prompt_builder`).
    *   Sends requests to the `semantic_judge` model API in batches, respecting rate limits (`rpm_limit`, `min_batch_interval`). The prompt likely asks the judge to compare the golden diagnosis to each ranked diagnosis in the text.
    *   Collects the raw text responses from the semantic judge model.
5.  **Result Processing (`process_results`):**
    *   Iterates through the raw results from the batch processing step.
    *   Uses `parse_judged_semantic` (from `bench29.libs.judges.semantic.parsers.parser_libs`) to attempt parsing the structured semantic relationship judgments (e.g., for each ranked diagnosis: semantic category, reasoning) from the model's text response. It uses the `ranked_differential_diagnosis_nested_dict` to link results back to the original data if needed by the parser.
    *   Separates successfully parsed results from failures.
6.  **Database Storage (`add_semantic_results_to_db`):**
    *   Takes the list of successfully parsed semantic relationship judgments.
    *   Inserts these judgments into the appropriate database table (e.g., `differential_diagnosis_to_semantic_relationship` or a dedicated results table).
7.  **Statistics and Exit:** Calculates and prints timing and throughput statistics. Waits for user input before exiting (in both modes).

### Key Functions (Endpoint Mode)

This section details the core functions used in Endpoint Mode.

#### `set_settings(prompt_name)`

```python
"""Initializes database session, asynchronous handler, and prompt builder.

Args:
    prompt_name (str): The name of the prompt class/function to use (e.g., 'Semantic_prompt').

Returns:
    tuple: A tuple containing:
        - session: SQLAlchemy database session object.
        - handler: An instance of AsyncModelHandler for API calls.
        - semantic_prompt_builder: The instantiated prompt builder object.
"""
```

#### `retrieve_and_make_prompts(differential_diagnosis_model, test_name, session, verbose, max_diagnoses)`

```python
"""Retrieves differential diagnoses and golden diagnoses, processes them, and prepares objects for batching.

This function orchestrates the data preparation pipeline for semantic comparison:
1. Fetches individual ranked diagnosis entries (`DifferentialDiagnosis2Rank` objects)
   from the database based on the specified model and test name (hospital).
2. Fetches the corresponding golden standard diagnosis for each case involved.
3. Groups the ranked diagnoses into a list of nested dictionaries using
   `create_nested_diagnosis_dict`. Each nested dictionary represents a complete
   differential diagnosis set for a specific case/model combination.
4. Transforms this list into a flat dictionary using `dif_diagnosis_dict2plain_text_dict_with_real_diagnosis`.
   The keys are composite strings (`f"{case_id}_{model_id}_{diff_diag_id}"`), and the values are
   multi-line strings containing BOTH the golden diagnosis AND the formatted list of ranked
   LLM diagnoses, separated by a specific string.
5. Converts this flat dictionary into a list of `DiagnosisTextWrapper` objects using
   `convert_dict_to_objects`. Each object has `.id` (composite key) and `.text` (golden + ranked diagnoses).
   This format is required by `process_all_batches`.
6. Creates an intermediate dictionary mapping composite keys back to the original rank details
   using `nested_dict2rank_dict`, needed for result parsing.

Args:
    differential_diagnosis_model (str): The name of the model whose diagnoses are being judged.
    test_name (str): The identifier for the test run (e.g., hospital name).
    session: SQLAlchemy database session object.
    verbose (bool): If True, prints detailed progress messages.
    max_diagnoses (int | None): Maximum number of diagnosis sets to process. If None, process all.

Returns:
    tuple: A tuple containing:
        - ranked_differential_diagnosis_objects (list): List of `DiagnosisTextWrapper` objects ready for batching.
        - ranked_differential_diagnosis_nested_dict (dict): Intermediate dictionary mapping composite keys to rank details.
"""
```

#### `process_results(results, ranked_differential_diagnosis_nested_dict, session, verbose, semantic_categories=None)`

```python
"""Processes the raw results from the batch API calls, parses semantic relationship judgments.

Iterates through the results obtained from `process_all_batches`. For each result,
it attempts to parse the semantic relationship judgment using `parse_judged_semantic`.
It separates successfully parsed results from failures.

Args:
    results (list): The list of result dictionaries returned by `process_all_batches`.
    ranked_differential_diagnosis_nested_dict (dict): The intermediate dictionary mapping composite keys
        to original rank details, used by the parser to link results back to original data.
    session: SQLAlchemy database session object.
    verbose (bool): If True, prints warnings for results that couldn't be parsed.
    semantic_categories (set | None): A set of valid semantic category strings.
        Defaults if None.

Returns:
    tuple: A tuple containing:
        - semantic_judge_results (list): A list of successfully parsed semantic results.
        - semantic_judge_fails (list): A list of results that failed parsing.
"""
```

#### `main(verbose, semantic_judge, differential_diagnosis_model, batch_size, max_diagnoses, rpm_limit, min_batch_interval, test_name, prompt_name)`

```python
"""Main execution logic for running the semantic judge in Endpoint mode.

Orchestrates the process: setup, data retrieval/transformation,
batch API calls for semantic judgment, result parsing, DB storage, and stats.

Args:
    verbose (bool): Enable detailed logging.
    semantic_judge (str): Model name for the semantic judge API.
    differential_diagnosis_model (str): Model name used for the diagnoses being judged.
    batch_size (int): Number of diagnoses per API call batch.
    max_diagnoses (int | None): Maximum number of diagnoses to process.
    rpm_limit (int): Requests per minute limit for the API.
    min_batch_interval (float): Minimum time between batches in seconds.
    test_name (str): Name for the test run.
    prompt_name (str): Name of the prompt configuration to use.
"""
```

### Key Dependencies / Libraries

*   **Standard:** `asyncio`, `time`, `argparse`, `sys`, `os`
*   **Database:** `sqlalchemy` (implicitly via `db.utils.db_utils` and query functions)
*   **Asynchronous API Handling:** `lapin` library (`AsyncModelHandler`, `process_all_batches`)
*   **Internal Bench29 Libs:**
    *   `bench29.libs.queries.common_queries`: `get_cases`, `get_case_to_golden_diagnosis_mapping`, `get_model_names_from_differential_diagnosis`, `get_ranks_for_hospital_and_model_id`, `get_model_id_from_name`, `create_nested_diagnosis_dict`.
    *   `bench29.libs.queries.semantic_queries`: `add_semantic_results_to_db`.
    *   `bench29.libs.utils.text_conversion`: `nested_dict2rank_dict`, `dif_diagnosis_dict2plain_text_dict_with_real_diagnosis`, `convert_dict_to_objects`.
    *   `bench29.libs.judges.prompts.semantic_judge_prompts`: Contains prompt classes/functions (e.g., `Semantic_prompt`).
    *   `bench29.libs.judges.semantic.parsers.parser_libs`: `parse_judged_semantic`.
*   **Database Utilities:** `db.utils.db_utils`: `get_session`
*   **Path Setup:** The script includes manual `sys.path` manipulation using `os` and `sys`. 