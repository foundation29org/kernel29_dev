# Summary of `judge_severity_async.py`

This script evaluates the severity of differential diagnoses generated by Large Language Models (LLMs) for clinical cases stored in a database. It uses another LLM (the "severity judge") to assess each diagnosis within a ranked list produced by a target LLM.

## Purpose

The primary goal is to asynchronously process numerous LLM-generated differential diagnoses, judge the severity of each individual diagnosis within those ranked lists using a designated severity judge model, and store these severity judgments back into the database. This allows for analysis of whether LLMs generate diagnoses of appropriate severity compared to the original case or potentially a gold standard.

## General Technical Overview

Here's a high-level overview of what this script does:
1.  Connects to a database containing clinical cases and diagnoses previously generated by different AI models.
2.  Selects diagnoses generated by a specific AI model (e.g., 'llama2_7b') for a particular dataset (e.g., 'ramedis').
3.  Formats the ranked list of diagnoses for each case into a text prompt suitable for another AI model (the "severity judge", e.g., 'llama3-70b').
4.  Sends these prompts asynchronously (many at once) to the severity judge AI.
5.  Receives the severity judgments (e.g., "mild", "severe", "critical") back from the AI.
6.  Parses these text-based judgments into a structured format.
7.  Stores the structured severity results back into the database.

The script can run using command-line arguments for automation (Endpoint Mode) or using fixed settings coded directly into the script for debugging (Debug Mode).

## Detailed Technical Overview

### Execution Modes

The script supports two execution modes, determined by the presence of the `--severity_judge` command-line argument:

1.  **Endpoint Mode:**
    *   Triggered when `--severity_judge` (and potentially other arguments like `--differential_diagnosis_model`, `--batch_size`, etc.) is provided.
    *   Uses command-line arguments to configure settings (models, batching parameters, etc.).
    *   Follows a structured, refactored execution path using the `main` function and helper functions (`set_settings`, `retrieve_and_make_prompts`, `process_results`).
    *   This is the intended mode for automated or production-like runs.

2.  **Debug Mode:**
    *   Triggered when `--severity_judge` is *not* provided.
    *   Uses hardcoded settings defined directly within the `if __name__ == "__main__":` block.
    *   Executes the core logic sequentially within the `else` block, *without* calling the refactored `main` or helper functions. The code in this block remains untouched from its original state for debugging and comparison purposes.

### Core Logic Flow (Endpoint Mode)

When run in Endpoint mode, the script follows these steps orchestrated by the `main` function:

1.  **Argument Parsing:** Reads command-line arguments to set parameters.
2.  **Settings Initialization (`set_settings`):**
    *   Establishes a database session (`get_session`).
    *   Initializes the asynchronous API handler (`AsyncModelHandler`).
    *   Loads the specified prompt template for the severity judge (`eval(prompt_name)()`).
3.  **Data Retrieval and Transformation (`retrieve_and_make_prompts`):**
    *   Fetches relevant ranked diagnosis records (`DifferentialDiagnosis2Rank` objects) from the database based on the target `differential_diagnosis_model` and `test_name` (hospital).
    *   **Groups** these flat records into a list of nested dictionaries, where each dictionary represents one full differential diagnosis set for a specific case/model (`create_nested_diagnosis_dict`).
    *   **Formats** each nested dictionary into a single plain text string containing the ranked diagnoses, mapped to a unique composite key (`f"{case_id}_{model_id}_{diff_diag_id}"`) in a flat dictionary (`dif_diagnosis_dict2plain_text_dict`).
    *   **Wraps** each key-value pair from the flat dictionary into a simple object (`DiagnosisTextWrapper`) having `.id` (the composite key) and `.text` (the formatted diagnosis list) attributes (`convert_dict_to_objects`). This final list of wrapper objects is required by the batch processing library (`process_all_batches`).
    *   Also creates an intermediate dictionary (`ranked_differential_diagnosis_nested_dict`) mapping the composite keys back to the original rank details (`nested_dict2rank_dict`), used later for result parsing.
4.  **Asynchronous Batch Processing (`process_all_batches`):**
    *   Takes the list of `DiagnosisTextWrapper` objects.
    *   Uses the `AsyncModelHandler` and the loaded prompt template.
    *   Sends requests to the `severity_judge` model API in batches, respecting rate limits (`rpm_limit`, `min_batch_interval`).
    *   Collects the raw text responses from the severity judge model.
5.  **Result Processing (`process_results`):**
    *   Iterates through the raw results from the batch processing step.
    *   Uses `parse_judged_severity` (from `bench29.libs.judges.severity.parsers.parser_libs`) to attempt parsing the structured severity judgment (disease, severity level, rank, reasoning) from the model's text response. It uses the `ranked_differential_diagnosis_nested_dict` to link results back to the original data if needed by the parser.
    *   Separates successfully parsed results from failures.
6.  **Database Storage (`add_severity_results_to_db`):**
    *   Takes the list of successfully parsed severity judgments.
    *   Inserts these judgments into the appropriate database table (e.g., `differential_diagnosis_to_severity` or a dedicated results table).
7.  **Statistics and Exit:** Calculates and prints timing and throughput statistics. Waits for user input before exiting (in both modes).

### Key Functions (Endpoint Mode)

This section details the core functions used in Endpoint Mode.

#### `set_settings(prompt_name)`

```python
"""Initializes database session, asynchronous handler, and prompt builder.

Args:
    prompt_name (str): The name of the prompt function to use (e.g., 'prompt_1').

Returns:
    tuple: A tuple containing:
        - session: SQLAlchemy database session object.
        - handler: An instance of AsyncModelHandler for API calls.
        - severity_prompt_builder: The instantiated prompt builder object.
"""
```

#### `retrieve_and_make_prompts(differential_diagnosis_model, test_name, verbose, max_diagnoses)`

```python
"""Retrieves differential diagnoses, processes them, and prepares objects for batching.

This function orchestrates the data preparation pipeline:
1. Fetches individual ranked diagnosis entries (`DifferentialDiagnosis2Rank` objects)
   from the database based on the specified model and test name (hospital).
   Each object contains fields like `cases_bench_id`, `differential_diagnosis_id`,
   `rank_position`, and `predicted_diagnosis`.
2. Groups these flat rank objects into a list of nested dictionaries using
   `create_nested_diagnosis_dict`. Each nested dictionary represents a complete
   differential diagnosis set for a specific case/model combination and contains
   a list of its ranked diagnoses.
   Example structure: `[{'model_id': M, 'cases_bench_id': C, 'differential_diagnosis_id': D,
                      'ranks': [{'rank_id': R1, 'rank': 1, 'predicted_diagnosis': 'DiagA'}, ...]}]
3. Transforms this list of nested dictionaries into a flat dictionary using
   `dif_diagnosis_dict2plain_text_dict`. The keys of this flat dictionary are composite
   strings (`f"{C}_{M}_{D}"`) uniquely identifying each differential diagnosis set,
   and the values are multi-line strings containing the formatted list of diagnoses
   (e.g., "- DiagA\n- DiagB").
4. Converts this flat dictionary into a list of simple objects (`DiagnosisTextWrapper`)
   using `convert_dict_to_objects`. Each object has an `.id` attribute (the composite key
   string from step 3) and a `.text` attribute (the formatted diagnosis string from step 3).
   This object format (`list[object]` where `object.id` and `object.text` exist) is required
   by the `lapin.utils.async_batch.process_all_batches` function.

Args:
    differential_diagnosis_model (str): The name of the model whose diagnoses are being judged.
    test_name (str): The identifier for the test run (e.g., hospital name).
    verbose (bool): If True, prints detailed progress messages.
    max_diagnoses (int | None): Maximum number of diagnosis *sets* (nested dicts) to process.
        Note: This limits based on the output of `create_nested_diagnosis_dict` before
        conversion to text/objects. If None, process all.

Returns:
    tuple: A tuple containing:
        - ranked_differential_diagnosis_objects (list): The final list of `DiagnosisTextWrapper` objects
          ready for `process_all_batches`.
        - ranked_differential_diagnosis_nested_dict (dict): The intermediate dictionary mapping composite
          keys to the list of rank dictionaries (`{'rank_id': R, 'rank': Pos, 'predicted_diagnosis': Diag}`),
          created by `nested_dict2rank_dict`. This is used later for result parsing.
"""
```

#### `process_results(results, ranked_differential_diagnosis_nested_dict, session, verbose, severity_levels=None)`

```python
"""Processes the raw results from the batch API calls, parses severity judgments.

Iterates through the results obtained from `process_all_batches`. For each result,
it attempts to parse the severity judgment using `parse_judged_severity`.
It separates successfully parsed results from failures.

Args:
    results (list): The list of result dictionaries returned by `process_all_batches`.
    ranked_differential_diagnosis_nested_dict (dict): The nested dictionary containing original
        diagnosis details, used by the parser to link results back to original data.
    session: SQLAlchemy database session object.
    verbose (bool): If True, prints warnings for results that couldn't be parsed.
    severity_levels (set | None): A set of valid severity level strings.
        Defaults to {"rare", "critical", "severe", "moderate", "mild"} if None.

Returns:
    tuple: A tuple containing:
        - severity_judge_results (list): A list of successfully parsed severity results
          (likely objects or dictionaries ready for database insertion).
        - severity_judge_fails (list): A list of results that failed parsing.
"""
```

#### `main(verbose, severity_judge, differential_diagnosis_model, batch_size, max_diagnoses, rpm_limit, min_batch_interval, test_name, prompt_name)`

```python
"""Main execution logic for running the severity judge in Endpoint mode.

This function orchestrates the entire process when the script is run
with command-line arguments (Endpoint mode). It sets up resources,
retrieves and transforms data, runs batch processing via API calls,
parses the results, stores them in the database, and prints statistics.

Args:
    verbose (bool): Enable detailed logging.
    severity_judge (str): Model name for the severity judge API.
    differential_diagnosis_model (str): Model name used for the diagnoses being judged.
    batch_size (int): Number of diagnoses per API call batch.
    max_diagnoses (int | None): Maximum number of diagnoses to process.
    rpm_limit (int): Requests per minute limit for the API.
    min_batch_interval (float): Minimum time between batches in seconds.
    test_name (str): Name for the test run.
    prompt_name (str): Name of the prompt configuration to use.
"""
```

### Key Dependencies / Libraries

*   **Standard:** `asyncio`, `time`, `argparse`, `sys`, `os`, `json`
*   **Database:** `sqlalchemy` (implicitly via `db.utils.db_utils` and query functions)
*   **Asynchronous API Handling:** `lapin` library (`AsyncModelHandler`, `process_all_batches`)
*   **Internal Bench29 Libs:**
    *   `bench29.libs.queries.severity_queries`: `get_severity_id`, `add_severity_results_to_db`
    *   `bench29.libs.queries.common_queries`: `get_model_names_from_differential_diagnosis`, `get_ranks_for_hospital_and_model_id`, `get_model_id_from_name`, `create_nested_diagnosis_dict`
    *   `bench29.libs.judges.prompts.severity_judge_prompts`: Contains prompt templates (e.g., `prompt_1`).
    *   `bench29.libs.utils.text_conversion`: `dif_diagnosis_dict2plain_text_dict`, `convert_dict_to_objects`, `nested_dict2rank_dict`.
    *   `bench29.libs.judges.severity.parsers.parser_libs`: `parse_judged_severity`.
*   **Database Utilities:** `db.utils.db_utils`: `get_session`
*   **Initialization:** `__init__` (Likely handles path setup or other initializations).

</rewritten_file> 